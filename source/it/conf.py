# Configuration file for the Sphinx documentation builder.
#
# This file only contains a selection of the most common options. For a full
# list see the documentation:
# https://www.sphinx-doc.org/en/master/usage/configuration.html

# -- Path setup --------------------------------------------------------------

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#
# import os
# import sys
# sys.path.insert(0, os.path.abspath('.'))



import os
import re
from pathlib import Path
import sys
import logging
import matplotlib.pyplot as plt

# Nuclear option - suppress ALL duplicate label warnings at the logging level
class DuplicateLabelFilter(logging.Filter):
    def filter(self, record):
        if hasattr(record, 'getMessage'):
            msg = record.getMessage()
            if 'duplicate label' in msg:
                return False
        return True

# Apply to ALL possible loggers that might emit these warnings
for logger_name in ['sphinx', 'myst_parser', 'docutils', 'sphinx.environment.collectors.asset', '']:
    logger = logging.getLogger(logger_name)
    logger.addFilter(DuplicateLabelFilter())

# Apply to root logger as well
logging.getLogger().addFilter(DuplicateLabelFilter())

sys.path.insert(0,
                os.path.abspath(os.path.join(os.path.dirname(__file__),
                                             '..', '..')))



# -- Project information -----------------------------------------------------

project = 'Superhero Data Science'
copyright = '2025, Dario Malchiodi'
author = 'Dario Malchiodi'

# The full version, including alpha/beta/rc tags
release = '1.0'


# -- General configuration ---------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.


extensions = [ # 'myst_parser',
               'sphinx_book_theme', 
            #    'sphinx.ext.mathjax',
               'sphinxcontrib.katex',
               'sphinx_exercise', 'sphinx_tabs.tabs',
               'sphinxcontrib.bibtex',
               'sphinx_external_toc',
               'sphinx_proof',
               'sphinx_exercise',
               'sphinx.ext.autosectionlabel',
               'myst_nb',
               'sds',
               'sds.sphinx_ext_custom_figure',
               'sds.sphinx_ext_custom_table',
               'sds.numref_to_ref',
               'sds.sphinx_custom_codeblock',
               'sphinxcontrib.mermaid',
                ]

# nb_code_cell_render_options = {
#     'python3': { 'lexer': 'python' }
# }
# pygments_style = 'friendly'  # or "friendly", "monokai", etc.
# highlight_language = 'python'

nb_execution_mode = "cache"
nb_execution_timeout = 300

# nb_render_priority = ["text/plain", "text/html"]
nb_mime_priority_overrides = [
    ("text/html", "text/html", 1),
    ("text/plain", "text/plain", 2),
]

nb_execution_allow_errors = False
nb_execution_raise_on_error = True
nb_execution_excludepatterns = []

# Allow errors for cells tagged with 'raises-exception'
nb_merge_streams = True



bibtex_bibfiles = ['../references.bib']
bibtex_reference_style = 'author_year'

# myst_enable_extensions = [
#     'html_admonition',
#     'html_image',
#     'colon_fence',
#     'amsmath',
#     'dollarmath',
#     'tabs'
# ]

myst_config = {
    "enable_extensions": [
        "amsmath",
        "dollarmath",
        "html_admonition",
        "html_image",
        "colon_fence",
        "tabs",
        "deflist",
        "linkify",
        "replacements",
        "substitution",
        "smartquotes",
        "tasklist",
    ],
    "heading_anchors": 3,
    "number_code_blocks": ["python", "bash", "shell", "javascript", "css", "html", "yaml", "json", "xml", "sql", "r", "julia", "matlab", "rust", "go", "java", "cpp", "c"],
    "title_to_header": True,
}

myst_enable_extensions = ["dollarmath", "amsmath"]


# myst_heading_start_level = 2

root_doc = 'landing'

external_toc_path = '_toc.yml'
external_toc_exclude_missing = False
html_link_suffix = ''

# Enable figure and table numbering within chapters
numfig = True
numfig_format = {
    'figure': 'Figura %s',
    'table': 'Tabella %s', 
    'code-block': 'Algoritmo %s',
    'section': 'Paragrafo %s'
}
numfig_secnum_depth = 1

# Additional numbering and cross-reference settings
numbered_toctree = True
myst_heading_anchors = 3
myst_number_code_blocks = []

# Enable automatic section labels with numbering
autosectionlabel_prefix_document = True
autosectionlabel_maxdepth = None

# Basic settings for cross-references
html_secnumber_suffix = '. '
toc_object_entries_show_parents = 'hide'

# Add any paths that contain templates here, relative to this directory.
templates_path = ['../_templates']

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#
# This is also used if you do content translation via gettext catalogs.
# Usually you set "language" from the command line for these cases.
language = 'it'
locale_dirs = ['../locales/'] # Path to your .po/.mo files
gettext_compact = False

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
# This pattern also affects html_static_path and html_extra_path.
exclude_patterns = []


# -- Options for HTML output -------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#
html_theme = 'sphinx_book_theme'
html_title = 'Superhero Data Science'
html_logo = '../_static/img/logo.png'
html_favicon = '../_static/img/sds.ico'

html_theme_options = {
    'home_page_in_toc': True,
    'show_toc_level': 3,
    'show_navbar_depth': 3,
    'secondary_sidebar_items': {},
    # 'number_toc': True,
    'pygments_light_style': 'abap',
    'pygments_dark_style': 'native',
    'article_header_end': [],  # Enable article header area for language switcher
    'extra_footer': '<p><a rel="license" '
                    'href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.it"'
                    'target="_blank"> CC BY-NC-SA 4.0</a></p>',
}

html_context = {
    "show_code_label": "Mostra codice",
    "hide_code_label": "Nascondi codice",
    "pyscript_wait_label": "Attendi il caricamento di PyScript",
}

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']
html_css_files = ['custom.css', 'custom_it.css']

html_js_files = [
    'custom.js',
    # 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js',
    # 'https://pyscript.net/releases/2025.5.1/core.js'
    # "https://cdn.jsdelivr.net/npm/vega@5",
    # "https://cdn.jsdelivr.net/npm/vega-lite@5",
    # "https://cdn.jsdelivr.net/npm/vega-embed@6",
]

# mathjax_path = "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"

# # mathjax3_config = {
# #     'options': {
# #        'ignoreHtmlClass': 'no-mathjax',
# #        'processHtmlClass': 'mathjax_process'},
# #     'tex': { 'inlineMath': [['$', '$'], ['\\(', '\\)']] }
# # }

myst_update_mathjax = False  # evita che MyST riscriva la config
# mathjax3_config = {
#   "options": {"ignoreHtmlClass": ".*", "processHtmlClass": "mjx-process"},
#   "tex": {
#     "inlineMath": [['$', '$'], ['\\(', '\\)']],
#     "displayMath": [['$$','$$'], ['\\[','\\]']],
#   },
# }

mermaid_version = "10.6.1"  # Use a recent version that supports more features

mermaid_init_js = """
mermaid.initialize({
    startOnLoad: true,
    theme: 'neutral',
    themeVariables: {
        primaryColor: '#fff8e1',
        primaryTextColor: '#333',
        primaryBorderColor: '#ffb300',
        lineColor: '#777',
        secondaryColor: '#e3f2fd',
        tertiaryColor: '#fff'
    }
});
"""

def reinsert_code_cells(app, exception):
    """Post-process HTML files to move code cells to their placeholder positions"""
    if exception or app.builder.name != 'html':
        return
    
    import logging
    logger = logging.getLogger(__name__)
    
    build_dir = Path(app.outdir)
    
    for html_file in build_dir.rglob('*.html'):
        content = html_file.read_text(encoding='utf-8')
        original_content = content
        
        # Extract all cells with their IDs and HTML content
        cell_pattern = r'<!-- CELL-MARKER-(\d+)-START -->(.*?)<!-- CELL-MARKER-\1-END -->\s*'
        cells = {}
        
        for match in re.finditer(cell_pattern, content, re.DOTALL):
            cell_id = match.group(1)
            cell_html = match.group(2).strip()
            cells[cell_id] = cell_html
        
        # Remove all cell markers from content
        content = re.sub(cell_pattern, '', content, flags=re.DOTALL)
        
        # Replace placeholders with actual cell HTML
        def replace_placeholder(match):
            cell_id = match.group(1)
            
            if cell_id not in cells:
                error_msg = f"Placeholder {cell_id} found but corresponding cell not extracted"
                logger.error(f"{html_file.name}: {error_msg}")
                raise ValueError(error_msg)
            
            return cells[cell_id]
        
        placeholder_pattern = r'<!-- CELL-PLACEHOLDER-(\d+) -->'
        content = re.sub(placeholder_pattern, replace_placeholder, content)
        
        # Verify no placeholders remain unreplaced
        remaining_placeholders = re.findall(placeholder_pattern, content)
        if remaining_placeholders:
            error_msg = f"Unreplaced placeholders found: {remaining_placeholders}"
            logger.error(f"{html_file.name}: {error_msg}")
            raise ValueError(error_msg)
        
        # Write back if changed
        if content != original_content:
            html_file.write_text(content, encoding='utf-8')
            logger.info(f"Post-processed {html_file.relative_to(build_dir)}")


def strip_out_code_cells(app, env, docnames):
    """Extract code-cells from admonitions/examples before Sphinx processes them"""
    if app.builder.name != 'html':
        return
    
    import logging
    logger = logging.getLogger(__name__)
    
    source_dir = Path(app.srcdir)
    
    # If docnames is None, process all documents (full rebuild)
    if docnames is None:
        docnames = list(env.found_docs) if hasattr(env, 'found_docs') else []
    
    # If still empty, scan all .md files recursively
    if not docnames:
        md_files = list(source_dir.rglob('*.md'))
    else:
        # Convert docnames to file paths
        md_files = []
        for docname in docnames:
            md_path = source_dir / f"{docname}.md"
            if md_path.exists():
                md_files.append(md_path)
    
    cell_counter = [0]  # Use list to allow modification in nested function
    
    for md_file in md_files:
        try:
            content = md_file.read_text(encoding='utf-8')
            original_content = content
            
            # Pattern to match admonitions/examples with N backticks (capture the backticks)
            directive_pattern = r'(`{3,})\{(admonition|prf:example)([^\}]*)\}([^\n]*)\n(.*?)\n\1(?!`)'
            
            def extract_cells(match):
                outer_backticks = match.group(1)
                directive_type = match.group(2)
                directive_args = match.group(3)
                directive_title = match.group(4)
                body = match.group(5)
                
                # Count outer backticks to determine inner backticks for code-cells
                outer_count = len(outer_backticks)
                inner_count = outer_count - 1
                inner_backticks = '`' * inner_count
                
                # Find all code-cells within this directive
                cell_pattern = rf'{re.escape(inner_backticks)}\{{code-cell\}}[^\n]*\n(.*?)\n{re.escape(inner_backticks)}(?!`)'
                cells = list(re.finditer(cell_pattern, body, re.DOTALL))
                
                if not cells:
                    return match.group(0)
                
                # First pass: assign IDs to cells in forward order
                cell_data = []
                for cell_match in cells:
                    cell_counter[0] += 1
                    cell_id = cell_counter[0]
                    cell_data.append((cell_match, cell_id))
                
                # Second pass: extract cells and replace with placeholders in reverse order
                extracted_cells = []
                modified_body = body
                
                for cell_match, cell_id in reversed(cell_data):
                    # Extract the full cell
                    cell_content = cell_match.group(0)
                    
                    # Replace cell with placeholder in body
                    placeholder = f'<!-- CELL-PLACEHOLDER-{cell_id} -->'
                    modified_body = modified_body[:cell_match.start()] + placeholder + modified_body[cell_match.end():]
                    
                    # Store extracted cell with markers (prepend to maintain order)
                    marked_cell = f'<!-- CELL-MARKER-{cell_id}-START -->\n{cell_content}\n<!-- CELL-MARKER-{cell_id}-END -->\n\n'
                    extracted_cells.insert(0, marked_cell)
                
                # Reconstruct: extracted cells + modified directive
                result = ''.join(extracted_cells)
                result += f'{outer_backticks}{{{directive_type}{directive_args}}}{directive_title}\n{modified_body}\n{outer_backticks}'
                
                return result
            
            # Apply the transformation
            content = re.sub(directive_pattern, extract_cells, content, flags=re.DOTALL)
            
            # Write back if changed
            if content != original_content:
                md_file.write_text(content, encoding='utf-8')
                logger.info(f"Preprocessed {md_file.relative_to(source_dir)}: extracted {cell_counter[0]} code-cells")
        
        except Exception as e:
            logger.warning(f"Error processing {md_file}: {e}")


def setup(app):
    import json
    import os

    # Load URL mapping for language switching
    mapping_path = os.path.join(os.path.dirname(__file__), '..', '_templates', 'url_mapping.json')
    try:
        with open(mapping_path, 'r', encoding='utf-8') as f:
            url_mapping = json.load(f)
        app.config.html_context = getattr(app.config, 'html_context', {})
        app.config.html_context['url_mapping'] = url_mapping
        print(f">>> URL mapping loaded with {len(url_mapping)} entries")
    except Exception as e:
        print(f">>> Warning: Could not load URL mapping: {e}")
        app.config.html_context = getattr(app.config, 'html_context', {})
        app.config.html_context['url_mapping'] = {}

    # Aggiorna le opzioni KaTeX in modo sicuro senza usare add_config_value
    opts_str = getattr(app.config, 'katex_options', '{}')
    try:
        opts_dict = json.loads(opts_str)
    except json.JSONDecodeError:
        opts_dict = {}

    opts_dict.update({
        "throwOnError": False,
        "processHtmlClass": ".*",
        "strict": "ignore"  # utile per ignorare simboli non standard LaTeX
    })

    app.config.katex_options = json.dumps(opts_dict)

    # Carica JS e CSS di KaTeX
    app.add_js_file('https://cdn.jsdelivr.net/npm/katex@0.18.2/dist/katex.min.js')
    app.add_css_file('https://cdn.jsdelivr.net/npm/katex@0.18.2/dist/katex.min.css')

    app.add_js_file(f'https://cdn.jsdelivr.net/npm/mermaid@{app.config.mermaid_version}/dist/mermaid.min.js')
    
    app.connect('env-before-read-docs', strip_out_code_cells)
    app.connect('build-finished', reinsert_code_cells)
    return {'version': '0.1', 'parallel_read_safe': True}